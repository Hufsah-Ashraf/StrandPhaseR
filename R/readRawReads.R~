#' This function will take phased info for each haplotype and will use all available reads to fill in missing alleles
#' specific reads
#' 
#' @param bamfilespath
#' @param chromosomes
#' @param regions
#' @param pairedEndReads
#' @import GenomicRanges
#' @importFrom Rsamtools indexBam scanBamHeader ScanBamParam scanBamFlag
#' @importFrom GenomicAlignments readGAlignmentPairs readGAlignments first last
#' 
#' @author David Porubsky
#' @export
 
readRawReads <- function(bamfilespath, chromosomes, pairedEndReads=TRUE, min.mapq=10, saveRData=FALSE) {
  ptm <- proc.time()
  
  file.list <- list.files(bamfilespath, pattern=".bam$", full=T)
  message("Loading reads from ", length(file.list), " bamfiles")
  
  bams.grl <- GenomicRanges::GRangesList()
  for (bamfile in file.list) {
    #message("Working on file ",bamfile)
    
    ID <- basename(bamfile)
    
    ## Get chromosome size
    file.header <- Rsamtools::scanBamHeader(bamfile)[[1]]
    chrom.lengths <- file.header$targets
    chroms.in.data <- names(chrom.lengths)
    if (is.null(chromosomes)) {
      chromosomes <- chroms.in.data
    }
    
    ## Get chromsosomes to load
    chroms2use <- intersect(chromosomes, chroms.in.data)
    
    if (length(chroms2use)==0) {
      chrstring <- paste0(chromosomes, collapse=', ')
      stop('The specified chromosomes ', chrstring, ' do not exist in the data.')
    }
    gr <- GenomicRanges::GRanges(seqnames=Rle(chroms2use), ranges=IRanges(start=rep(1, length(chroms2use)), end=chrom.lengths[chroms2use]))
    
    ## Check if bamindex exists
    bamindex=bamfile
    bamindex.raw <- sub('\\.bai$', '', bamindex)
    bamindex <- paste0(bamindex.raw,'.bai')
    if (!file.exists(bamindex)) {
      bamindex.own <- Rsamtools::indexBam(bamfile)
      warning("Couldn't find BAM index-file ",bamindex,". Creating our own file ",bamindex.own," instead.")
      bamindex <- bamindex.own
    }
    
    ## Load reads into GRanges object
    if (pairedEndReads) {
      suppressWarnings( data.raw <- GenomicAlignments::readGAlignmentPairs(bamfile, index=bamindex, param=Rsamtools::ScanBamParam(which=range(gr), what=c('seq', 'qual','mapq','cigar'), flag=scanBamFlag(isDuplicate=F))) )
    } else {
      suppressWarnings( data.raw <- GenomicAlignments::readGAlignments(bamfile, index=bamindex, param=Rsamtools::ScanBamParam(which=range(region), what=c('seq', 'qual','mapq','cigar'), flag=scanBamFlag(isDuplicate=F))) )
    }
    
    if (pairedEndReads) {
      data.first <- as(GenomicAlignments::first(data.raw), 'GRanges')
      data.last <- as(GenomicAlignments::last(data.raw), 'GRanges')
      strand(data.last) <- strand(data.first)
      data <- sort(c(data.first, data.last))
    } else {
      data <- as(data.raw, 'GRanges')
    }
    
    ## Filter by mapping quality
    if (!is.null(min.mapq)) {
      if (any(is.na(mcols(data)$mapq))) {
        warning(paste0(file,": Reads with mapping quality NA (=255 in BAM file) found and removed. Set 'min.mapq=NULL' to keep all reads."))
        mcols(data)$mapq[is.na(mcols(data)$mapq)] <- -1
      }
      data <- data[mcols(data)$mapq >= min.mapq]
    }
    seqlevels(data) <- seqlevels(gr)
    
    ## Store all data in GRanges list 
    bams.grl[[ID]] <- data
    
  }
  time <- proc.time() - ptm
  message("Time spent: ",round(time[3],2),"s")
  
  return(bams.grl)
}
